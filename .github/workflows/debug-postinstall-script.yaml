name: Debug postinstall script
on:
  push:
    branches:
      - main
    tags-ignore:
      - "**"
  pull_request:
jobs:
  setup:
    if: |
      ! (
        contains(github.event.pull_request.labels.*.name, 'invalid')
        || contains(github.event.pull_request.labels.*.name, 'skip ci')
      )
    runs-on: ubuntu-latest
    env:
      repo-dirname: repo
      artifact-name: debug-package@${{ github.event.number && format('pr-{0}', github.event.number) || github.sha }}
      archive-filename: debug-package.tar.zst
      tarball-name: foo.tgz
    outputs:
      artifact-name: ${{ env.artifact-name }}
      archive-filename: ${{ env.archive-filename }}
      tarball-name: ${{ env.tarball-name }}
    steps:
      - uses: actions/checkout@v3
        with:
          path: ./${{ env.repo-dirname }}

      - name: Setup debug package
        shell: bash
        run: |
          readonly root_path="$PWD"
          (
            cd './${{ env.repo-dirname }}/postinstall-debug-package/' && {
              cp ./postinstall.js "${root_path}/"
              npm pack
              mv ./*.tgz "${root_path}/${{ env.tarball-name }}"
            }
          )
          {
            echo '{}' | jq '.scripts.postinstall = "node ./postinstall.js --type=Project"'
          } > ./package.json

          find . -mindepth 1 -maxdepth 1 -type d -name '${{ env.repo-dirname }}' -prune -o -print0 \
            | xargs -0 tar -c --file './${{ env.archive-filename }}' --zstd --verbose
        # Note: Convert the debug package into a single archive file. This is for the following reasons:
        #       + Maintaining file permissions and case sensitive files
        #         see https://github.com/actions/upload-artifact/blob/v3.1.2/README.md#maintaining-file-permissions-and-case-sensitive-files
        #       + Reduce the number of API calls
        #         see https://github.com/actions/upload-artifact/blob/v3.1.2/README.md#too-many-uploads-resulting-in-429-responses

      - name: Upload debug package
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.artifact-name }}
          path: ${{ env.archive-filename }}
          retention-days:
            1
            # The resulting artifact of the build is intended to be used in the next job.
            # There is no need to store them for long periods of time.

  debug-postinstall-script:
    needs: setup
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]
        package-manager:
          # - npm@1.4.29  # Throws "Reference Error: primordials is not defined"
          # - npm@2.15.12 # Throws "peerinvalid The package ajv@6.12.6 does not satisfy its siblings' peerDependencies requirements!"
          # - npm@3.10.10 # Throws "cb.apply is not a function"
          # - npm@4.6.1   # Throws "cb.apply is not a function"
          # - npm@5.10.0  # Throws "cb.apply is not a function"
          - npm@6.14.18
          - npm@7.24.2
          - npm@8.19.4
          - npm@9.6.4
          - yarn@1.22.19
          - yarn@2.4.3
          - yarn@3.5.0
          - yarn@4.0.0-rc.42
          # - pnpm@1.43.1  # Throws "Internal Error: Cannot find module '.../bin/pnpm.js'"
          # - pnpm@2.25.7  # Throws "TypeError: cb.apply is not a function"
          # - pnpm@3.8.1   # Throws "EACCES: permission denied, mkdir '/usr/local/pnpm-global'"
          # - pnpm@4.14.4  # Throws "EACCES: permission denied, mkdir '/usr/local/pnpm-global'"
          # - pnpm@5.18.10 # Throws "EACCES: permission denied, mkdir '/usr/local/pnpm-global'"
          # - pnpm@6.35.1  # Throws "ELIFECYCLEâ€‰ Command failed with exit code -4058. .../node_modules/foo postinstall: Failed"
          - pnpm@7.32.0
          - pnpm@8.2.0
          - bun@0.5.9
        exclude:
          - package-manager: bun@0.5.9
            os: windows-latest
    runs-on: ${{ matrix.os }}
    steps:
      - name: Download debug package
        uses: actions/download-artifact@v3
        with:
          name: ${{ needs.setup.outputs.artifact-name }}
          path: ~/debug-package-artifact

      - name: Restore debug package
        shell: bash
        run: tar -x --file ~/debug-package-artifact/'${{ needs.setup.outputs.archive-filename }}' --zstd --verbose

      - name: Install Bun
        if: startsWith(matrix.package-manager, 'bun@')
        shell: bash
        run: |
          npm install --global --force '${{ matrix.package-manager }}'
          if [[ '${{ runner.os }}' == 'Windows' ]]; then
            # Windows installs global packages to a directory that has lower priority than the default node install so we also need to edit $PATH
            # see https://github.com/vercel/turbo/pull/1632/files#diff-b92a3120126a9ffe46d7d5ec3a8496ef1eac951db09e1972fac7c78438e36c42R69
            npm config get prefix >> "${GITHUB_PATH}"
          fi

      - name: Enable Corepack (Automatically setup a package manager for Node.js)
        if: |
          ! startsWith(matrix.package-manager, 'bun@')
        shell: bash
        run: |
          if type yarn >/dev/null 2>&1; then
            echo '[command]npm uninstall --global yarn'
            npm uninstall --global yarn
          fi
          if type pnpm >/dev/null 2>&1; then
            echo '[command]npm uninstall --global pnpm'
            npm uninstall --global pnpm
          fi
          corepack enable
          corepack enable npm
          < ./package.json jq '.packageManager = "${{ matrix.package-manager }}"' > ./package.json~new
          mv ./package.json~new ./package.json

      - name: Run install
        uses: actions/github-script@v6
        env:
          RUNNER_TEMP_DIR: ${{ runner.temp }}
          TARBALL_PATH: ./${{ needs.setup.outputs.tarball-name }}
        with:
          script: |
            const fs = require('fs/promises');
            const os = require('os');
            const path = require('path');
            const { inspect } = require('util');

            function insertHeader(headerStr, lineList, linePrefix) {
              if (lineList.length < 1) return [];
              return [
                headerStr,
                ...lineList.map((...args) =>
                  typeof linePrefix === 'function'
                  ? linePrefix(...args)
                  : (linePrefix ? String(linePrefix) + args[0] : args[0])
                ),
              ];
            }
            /**
             * @see https://jsonlines.org/
             */
            function parseJsonLines(jsonLinesText) {
              let valueCount = 0;
              return jsonLinesText
                .split('\n')
                .flatMap((jsonText, index) => {
                  // see https://www.rfc-editor.org/rfc/rfc8259#section-2:~:text=ws%20=,carriage%20return
                  if (!/[^ \t\n\r]/.test(jsonText)) return [];
                  valueCount++;

                  try {
                    return [JSON.parse(jsonText)];
                  } catch (error) {
                    error.message += ` in line ${index + 1} (value ${valueCount})`;
                    throw error;
                  }
                });
            }
            function indentStr(str, prefix, firstPrefix='') {
              if (typeof prefix !== 'number' && typeof prefix !== 'string')
                prefix = String(prefix);
              if (typeof firstPrefix !== 'string')
                firstPrefix = String(firstPrefix);

              const indentLength = Math.max(
                typeof prefix === 'number' ? prefix : prefix.length,
                firstPrefix.length,
              );
              const prefixStr = typeof prefix === 'number'
                ? ' '.repeat(indentLength)
                : prefix + ' '.repeat(indentLength - prefix.length);
              const firstPrefixStr = firstPrefix
                ? firstPrefix + ' '.repeat(indentLength - firstPrefix.length)
                : prefixStr;

              return str.replace(
                /^(?!$)/gms,
                (_, offset) => offset === 0 ? firstPrefixStr : prefixStr,
              );
            }
            function filepathUsingEnvNameList(filepath, env, excludeEnv = {}) {
              return Object.entries(env ?? {})
                .flatMap(([key, value]) => {
                  if (!value || /^(?:[A-Z]:)?[/\\]?$/i.test(value) || excludeEnv[key] === value) return [];

                  if (filepath.startsWith(value)) {
                    return {
                      envName: key,
                      path: `\${${key}}` + filepath.substring(value.length),
                      rawPath: filepath,
                    };
                  }
                  if (path.sep !== '/' && filepath.startsWith(value.replace('/', path.sep))) {
                    return {
                      envName: key,
                      path: `\${${key}.replace('/', '${path.sep}')}` + filepath.substring(value.length),
                      rawPath: filepath,
                    };
                  }

                  return [];
                })
            }

            const tarballFullpath = await core.group('Move debugger package tarball', async () => {
              const rootDir = path.resolve(process.cwd(), '/');
              const dirList = [rootDir, os.homedir(), process.env.RUNNER_TEMP_DIR];
              const tarballPathList = dirList
                .map(dir => path.resolve(dir, 'debugger-package.tgz'))
                // Exclude paths that belong to different drive letters
                .filter(filepath => filepath.startsWith(rootDir))
                // Sort by shortest filepath
                .sort((a, b) => a.length - b.length);
              const origTarballPath = path.resolve(process.env.TARBALL_PATH);
              console.log({
                origTarballPath,
                tarballPathList,
              });

              for (const tarballPath of tarballPathList) {
                try {
                  await fs.rename(origTarballPath, tarballPath);
                  console.log({ tarballPath });
                  return tarballPath;
                } catch (error) {
                  console.log(error);
                }
              }

              console.log({ tarballPath: origTarballPath });
              return origTarballPath;
            });

            const defaultEnv = Object.fromEntries(
              Object.entries(process.env)
                .filter(([key]) => !/^(?:DISABLE_)?(?:npm_|yarn_|PNPM_|BUN_)|^(?:INIT_CWD|PROJECT_CWD)$/i.test(key))
            );

            const packageManager = '${{ matrix.package-manager }}';
            const pmType = packageManager.replace(/@.+$/s, '');
            await core.group('Show node and package manager version', async () => {
              await exec.exec('node --version', [], { env: defaultEnv });
              await exec.exec(pmType, ['--version'], { env: defaultEnv });
            });

            if (pmType === 'yarn' && !packageManager.startsWith('yarn@1.')) {
              // see https://github.com/yarnpkg/berry/discussions/3486#discussioncomment-1379344
              await core.group('Setup', async () => {
                await exec.exec('yarn config set enableImmutableInstalls false', [], { env: defaultEnv });
              });
            }

            const tarballPath = path.relative(process.cwd(), tarballFullpath);
            const tmpDirpath = await fs.mkdtemp(os.tmpdir() + path.sep);
            const installEnv = {
              ...defaultEnv,
              POSTINSTALL_TYPE: 'Local Dependencies',
              DEBUG_DATA_JSON_LINES_PATH: path.join(tmpDirpath, 'debug-data.jsonl'),
              DEBUG_ORIGINAL_ENV_JSON_PATH: path.join(tmpDirpath, 'orig-env.json'),
            };
            await fs.writeFile(
              installEnv.DEBUG_ORIGINAL_ENV_JSON_PATH,
              JSON.stringify(installEnv, (_, value) => value === undefined ? null : value),
            );
            if (pmType === 'npm') {
              await exec.exec('npm install', [tarballPath], { env: installEnv });
            } else if (pmType === 'yarn') {
              if (packageManager.startsWith('yarn@1.')) {
                await exec.exec('yarn add', [tarballPath], { env: installEnv });
              } else {
                await exec.exec('yarn add', [tarballPath.replaceAll(path.sep, '/')], { env: installEnv });
              }
            } else if (pmType === 'pnpm') {
              await exec.exec('pnpm add', [tarballPath], { env: installEnv });
            } else if (pmType === 'bun') {
              await exec.exec('bun add', [tarballPath], { env: installEnv });
            }
            {
              const { GITHUB_STEP_SUMMARY } = defaultEnv;
              const binDir = path.resolve(process.cwd(), 'node_modules/.bin');
              const debugData = (
                await fs.readFile(installEnv.DEBUG_DATA_JSON_LINES_PATH, 'utf8')
                  .then(parseJsonLines)
                  .then(debugDataList => (
                    debugDataList.find(({ postinstallType }) => postinstallType === installEnv.POSTINSTALL_TYPE)
                    // Bun does not execute the "postinstall" script of installed dependencies.
                    // Instead, it uses the debug data from the project's "postinstall" script.
                    ?? debugDataList.find(({ postinstallType }) => pmType === 'bun' && /^Project$/i.test(postinstallType))
                    ?? {}
                  ))
                  .catch(error => ({}))
              );
              await fs.appendFile(
                GITHUB_STEP_SUMMARY,
                [
                  '```js',
                  `// Files in ${binDir}`,
                  ...insertHeader(
                    '// This path can also be got using environment variables:',
                    filepathUsingEnvNameList(binDir, debugData.env, installEnv).map(({ path }) => path),
                    '//     ',
                  ),
                  inspect(await fs.readdir(binDir).catch(error => error)),
                  '```',
                  '',
                  '',
                ].join('\n'),
              );
            }

            installEnv.POSTINSTALL_TYPE = 'Global Dependencies';
            await fs.writeFile(
              installEnv.DEBUG_ORIGINAL_ENV_JSON_PATH,
              JSON.stringify(installEnv, (_, value) => value === undefined ? null : value),
            );
            if (pmType === 'npm') {
              await exec.exec('npm install --global', [tarballPath], { env: installEnv });
            } else if (pmType === 'yarn') {
              if (packageManager.startsWith('yarn@1.')) {
                await exec.exec('yarn global add', [tarballPath], { env: installEnv });
              } else {
                // Note: On Windows, the "yarn dlx --package" command does not know the local filepath
                // TODO: Run this command using the local npm registry (e.g. local-npm or verdaccio)
                if (process.platform !== 'win32') {
                  await exec.exec('yarn dlx --package', [path.resolve(tarballPath), 'bar'], { env: installEnv });
                }
              }
            } else if (pmType === 'pnpm') {
              // The "pnpm add --global ..." command requires a global bin directory.
              // see https://github.com/pnpm/pnpm/issues/4658
              const PNPM_HOME = path.resolve(os.homedir(), '.pnpm-home');
              const pathEnv = Object.fromEntries(
                Object.entries(installEnv)
                  .filter(([key]) => /^PATH$/i.test(key))
                  .map(([key, value]) => [key, [value, PNPM_HOME].join(path.delimiter)])
              );
              const env = {
                ...installEnv,
                ...pathEnv,
                PNPM_HOME,
              };
              await fs.writeFile(
                env.DEBUG_ORIGINAL_ENV_JSON_PATH,
                JSON.stringify(env, (_, value) => value === undefined ? null : value),
              );

              await exec.exec('pnpm add --global', [path.resolve(tarballPath)], { env });
            } else if (pmType === 'bun') {
              await exec.exec('bun add --global', [path.resolve(tarballPath)], { env: installEnv });
            }
            {
              const { GITHUB_STEP_SUMMARY } = defaultEnv;
              const debugDataList = (
                await fs.readFile(installEnv.DEBUG_DATA_JSON_LINES_PATH, 'utf8')
                  .then(parseJsonLines)
                  .catch(error => {
                    if (error.code === 'ENOENT') return [];
                    throw error;
                  })
              );
              const { binCommand, binName, ...debugData } = (
                debugDataList
                  .find(({ postinstallType }) => postinstallType === installEnv.POSTINSTALL_TYPE)
                ?? {}
              );
              async function inspectInstalledBin(bindirPath) {
                const showAll = !binName;
                return await fs.readdir(bindirPath)
                  .then(files => {
                    if (showAll) return inspect(files);

                    const { binFiles = [], otherFiles = [] } = files.reduce(
                      ({ binFiles = [], otherFiles = [] }, file) => {
                        const isInstalledBin = file === binName || file.startsWith(`${binName}.`);
                        (isInstalledBin ? binFiles : otherFiles).push(file);
                        return { binFiles, otherFiles };
                      },
                      {},
                    );
                    return inspect(binFiles.concat(otherFiles), {
                      maxArrayLength: binFiles.length,
                    });
                  })
                  .catch(error => inspect(error));
              }

              const prefixEnvName = 'npm_config_prefix';
              if (binCommand?.result) {
                await fs.appendFile(
                  GITHUB_STEP_SUMMARY,
                  [
                    '```js',
                    indentStr([
                      `$(${binCommand.args.join(' ')})`,
                      `( ${binCommand.result} )`,
                    ].join('\n'), '// ', '// Files in '),
                    ...insertHeader(
                      '// This path can also be got using environment variables:',
                      filepathUsingEnvNameList(binCommand.result, debugData.env, installEnv).map(({ path }) => path),
                      '//     ',
                    ),
                    await inspectInstalledBin(binCommand.result),
                    '```',
                    '',
                    '',
                  ].join('\n'),
                );
              } else if (debugData.env?.[prefixEnvName]) {
                const prefix = debugData.env[prefixEnvName];
                // see https://docs.npmjs.com/cli/v9/configuring-npm/folders#executables
                const binDir = process.platform === 'win32'
                  ? prefix
                  : path.join(prefix, 'bin');

                const binDirUsingEnvNameList = filepathUsingEnvNameList(binDir, debugData.env, installEnv);
                await fs.appendFile(
                  GITHUB_STEP_SUMMARY,
                  [
                    '```js',
                    indentStr([
                      ...binDirUsingEnvNameList
                          .filter(({ envName }) => envName === prefixEnvName)
                          .map(({ path }) => path),
                      `( ${binDir} )`,
                    ].join('\n'), '// ', '// Files in '),
                    ...insertHeader(
                      '// This path can also be got using other environment variables:',
                      binDirUsingEnvNameList
                        .filter(({ envName }) => envName !== prefixEnvName)
                        .map(({ path }) => path),
                      '//     ',
                    ),
                    await inspectInstalledBin(binDir),
                    '```',
                    '',
                    '',
                  ].join('\n'),
                );
              } else if (pmType === 'bun') {
                const binCmdArgs = ['bun', 'pm', 'bin', '--global'];
                const binDir = await exec.getExecOutput(
                  binCmdArgs[0],
                  binCmdArgs.slice(1),
                  { env: installEnv },
                )
                  .then(({ stdout }) => stdout.trim());
                const debugData = (
                  debugDataList.find(({ postinstallType }) => postinstallType === installEnv.POSTINSTALL_TYPE)
                  // Bun does not execute the "postinstall" script of installed dependencies.
                  // Instead, it uses the debug data from the project's "postinstall" script.
                  ?? debugDataList.find(({ postinstallType }) => /^Project$/i.test(postinstallType))
                  ?? {}
                );
                await fs.appendFile(
                  GITHUB_STEP_SUMMARY,
                  [
                    '```js',
                    indentStr([
                      `$(${binCmdArgs.join(' ')})`,
                      `( ${binDir} )`,
                    ].join('\n'), '// ', '// Files in '),
                    ...insertHeader(
                      '// This path can also be got using environment variables:',
                      filepathUsingEnvNameList(binDir, debugData.env, installEnv).map(({ path }) => path),
                      '//     ',
                    ),
                    await inspectInstalledBin(binDir),
                    '```',
                    '',
                    '',
                  ].join('\n'),
                );
              }
            }

  # Successfully complete this job when all jobs have been completed.
  # Only by checking this job, it is possible to determine if CI is complete or not.
  # So we can simplify our GitHub status check configuration.
  # see https://github.com/orgs/community/discussions/26822
  # see https://github.com/sounisi5011/npm-packages/blob/2a5ca2de696eeb8b40a38de90580441c4c6c96e0/.github/workflows/ci.yaml#L482-L498
  complete:
    name: Complete Workflow
    needs: debug-postinstall-script
    if:
      always() && github.event.pull_request
      # This job is required only for Pull Requests.
      # It does not need to be run on other branches.
    runs-on: ubuntu-latest
    steps:
      - name: Check all job status
        # see https://docs.github.com/en/actions/learn-github-actions/contexts#needs-context
        # see https://docs.github.com/en/actions/learn-github-actions/expressions#contains
        if: |
          contains(needs.*.result, 'failure')
          || contains(needs.*.result, 'cancelled')
          || contains(needs.*.result, 'skipped')
        run: exit 1
